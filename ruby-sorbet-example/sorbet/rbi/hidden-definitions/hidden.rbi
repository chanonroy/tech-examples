# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class A
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def deconstruct(); end

  def intersect?(arg); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(arg); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end

  def n_significant_digits(); end

  def precision(); end

  def precision_scale(); end

  def scale(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(arg); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def dependencies_for(groups); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::DepProxy
  def clone(); end
end

class Bundler::DepProxy
  def self.get_proxy(dep, platform); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end

  def github(); end

  def ref(); end
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::Dsl
  def check_primary_source_safety(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_checksum(built_gem_path=T.unsafe(nil)); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def current_branch(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::LazySpecification
  def eql?(other); end

  def platform_string(); end
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::RemoteSpecification
  def required_rubygems_version(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def results_for(dependency, base); end

  def source_for(name); end
end

class Bundler::Resolver::SpecGroup
  def activated_platforms(); end

  def activated_platforms=(activated_platforms); end

  def sorted_activated_platforms(); end
end

class Bundler::Resolver::SpecGroup
  def self.create_for(specs, all_platforms, specific_platform); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def load_env_plugins(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def glob(); end

  def local?(); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def dependency_api_available?(); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def remote_names(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def missing_specs(); end
end

class Bundler::StubSpecification
  def extensions(); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*arg); end

  def attr_reader(*arg); end

  def attr_writer(*arg); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_error(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *arg); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def are_colors_supported?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

class Class
  def json_creatable?(); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.exists?(arg); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class Encoding
  def _dump(*arg); end
  CESU_8 = ::T.let(nil, ::T.untyped)
  CP720 = ::T.let(nil, ::T.untyped)
  IBM720 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def initialize(*arg); end
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  def compact(); end
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def initialize(*arg); end

  def transfer(*arg); end
end

class Fiber
  def self.blocking?(); end

  def self.current(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

class File
  def self.absolute_path?(arg); end

  def self.exists?(arg); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.latest_compact_info(); end

  def self.measure_total_time(); end

  def self.measure_total_time=(flag); end

  def self.total_time(); end

  def self.using_rvargc?(); end

  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  KERNEL_WARN_IGNORES_INTERNAL_ENTRIES = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::BasicSpecification
  def plugins(); end
end

module Gem::BundlerVersionFinder
  def self.prioritize!(specs); end
end

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::Dependency
  def prioritizes_bundler?(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(); end
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil), extension_dir=T.unsafe(nil)); end

  def self.get_relative_path(path, base); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

Gem::Installer::ExtensionBuildError = Gem::Ext::BuildError

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  LICENSE_REF = ::T.let(nil, ::T.untyped)
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.sort_priority(platform); end
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def unused_unwind_options(); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::DependencyGraph
  include ::Gem::TSort
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def self.keyword_init?(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def self.keyword_init?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def possibility_set(); end

  def possibility_set=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def self.keyword_init?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::VersionConflict
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  include ::Gem::Specification::YamlBackfiller
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def deleted_gem?(); end

  def removed_method_calls(); end

  def to_ruby(); end
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

module Gem::Specification::YamlBackfiller
  def to_yaml(opts=T.unsafe(nil)); end
end

module Gem::Specification::YamlBackfiller
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.latest_spec_for(name); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.find_config_file(); end

  def self.open_file(path, flags, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.solaris_platform?(); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def deconstruct_keys(arg); end
end

class Hash
  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end
end

class IO
  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(arg); end

  def ready?(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end
  PRIORITY = ::T.let(nil, ::T.untyped)
  READABLE = ::T.let(nil, ::T.untyped)
  WRITABLE = ::T.let(nil, ::T.untyped)
end

class IO::Buffer
  include ::Comparable
  def clear(*arg); end

  def copy(*arg); end

  def empty?(); end

  def external?(); end

  def free(); end

  def get_string(*arg); end

  def get_value(arg, arg1); end

  def hexdump(); end

  def initialize(*arg); end

  def internal?(); end

  def locked(); end

  def locked?(); end

  def mapped?(); end

  def null?(); end

  def pread(arg, arg1, arg2); end

  def pwrite(arg, arg1, arg2); end

  def read(arg, arg1); end

  def readonly?(); end

  def resize(arg); end

  def set_string(*arg); end

  def set_value(arg, arg1, arg2); end

  def size(); end

  def slice(arg, arg1); end

  def transfer(); end

  def valid?(); end

  def write(arg, arg1); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  HOST_ENDIAN = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAPPED = ::T.let(nil, ::T.untyped)
  NETWORK_ENDIAN = ::T.let(nil, ::T.untyped)
  PAGE_SIZE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
end

class IO::Buffer::AccessError
end

class IO::Buffer::AccessError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::LockedError
end

class IO::Buffer
  def self.for(arg); end

  def self.map(*arg); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.new(*arg); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
end

class Integer
  def self.try_convert(arg); end
end

class JSON::Ext::Generator::State
  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  def self.create_fast_state(); end

  def self.create_pretty_state(); end

  def self.load_file(filespec, opts=T.unsafe(nil)); end

  def self.load_file!(filespec, opts=T.unsafe(nil)); end
end

module Kernel
  def pretty_inspect(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class LoadError
  include ::DidYouMean::Correctable
end

class MatchData
  def match(arg); end

  def match_length(arg); end
end

class Method
  def private?(); end

  def protected?(); end

  def public?(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class NameError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class NoMatchingPatternKeyError
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class OpenStruct
  def __id__!(); end

  def __send__!(*arg); end

  def class!(); end

  def clone!(freeze: T.unsafe(nil)); end

  def define_singleton_method!(*arg); end

  def delete_field!(name); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def extend!(mod, *args); end

  def freeze!(); end

  def gem!(dep, *reqs); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_variable_get!(arg); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*arg); end

  def object_id!(); end

  def private_methods!(*arg); end

  def protected_methods!(*arg); end

  def public_method!(arg); end

  def public_methods!(*arg); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def send!(*arg); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_methods!(*arg); end

  def taint!(); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_s!(); end

  def trust!(); end

  def untaint!(); end

  def untrust!(); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class PP
  def self.width_for(out); end
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  def self._fork(); end
end

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.new(*args, name: T.unsafe(nil), &block); end
end

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  def %(arg); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

class Refinement
end

class Refinement
end

class RubyVM::AbstractSyntaxTree::Node
  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end
end

class RubyVM::InstructionSequence
  def script_lines(); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*arg); end

  def self.resume(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def shellescape(); end

  def shellsplit(); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringIO
  def self.new(*arg); end
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

class Struct
  def self.new(*arg); end
end

class Symbol
  def name(); end
end

class Thread
  def native_thread_id(); end
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread
  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

class UnboundMethod
  def private?(); end

  def protected?(); end

  def public?(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

